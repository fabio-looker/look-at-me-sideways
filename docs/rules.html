<!doctype html>
<html>
<head>
	<title>Fabio's Opinionated SQL & LookML Rules</title>
	<meta charset="utf8" />
</head>
<body>
<style>
	html {width:100%}
	body {background-color: #FAFAFA; margin: 2em auto; width:60em;}
	p,ul {width:80%;max-width:40em}
	li{margin-bottom: 0.5em;}
	details {padding-left:3em;}
	summary {margin-left:-3em;}
	code.block {display:block; white-space: pre-wrap; max-width:90%;margin:1em 0 1.5em 0; tab-size:2em;}
	code.good.block {background-color: #EFE; box-shadow: 2px 2px 10px 0px #9C9;}
	code.good.block::before {content:"# GOOD:"}
	code.good.block.sql::before {content:"-- GOOD:"}
	code.questionable.block {background-color: #FFE; box-shadow: 2px 2px 10px 0px #CC9;}
	code.questionable.block::before {content:"# QUESTIONABLE:"}
	code.questionable.block.sql::before {content:"-- QUESTIONABLE:"}
	code.bad.block{background-color: #FEE; box-shadow: 2px 2px 10px 0px #C99;}
	code.bad.block::before {content:"# BAD:"}
	code.bad.block.sql::before {content:"-- BAD:"}
</style>
Emphasis on opinionated. Don't say I didn't warn you!

<nav><ul>
<li> <a href="#terms">Terms</a></li>
<li> <a href="#key-dimensions">Key Dimensions</a></li>
<li> <a href="#other-fields">Other Fields</a></li>
<li> <a href="#derived-tables">Derived Tables</a></li>
<li> <a href="#explores">Explores</a></li>
<li> <a href="#out-of-scope">Out of Scope</a></li>
</ul></nav>

<h1 id="terms">Terms</h1>
	<details><summary>Distribution key</summary> In Redshift, Vertica, MemSQL, MS PDW and possibly some others, data can be distributed according to a particular value. For simplicity, I use the name distribution key, though different dialects may have different names for this.</details>
	<details><summary>Sort key</summary> Sort keys in Redshift, or partition columns in Big Query, clustered indexes in MS SQL Server or PDW, etc.</details>
	<details><summary>must</summary> Whenever a rule says something "must" be done, there shouldn't be any exceptions within your project. These are rules that need to be followed consistently since others will rely upon them being followed in their work elsewhere. </details>
	<details><summary>should</summary> Whenever a rule says that something "should" be done, there may be reasons to deviate from these rules, and doing so will not break any assumptions elsewhere. Whenever the rule is not followed, a comment should be used to indicate the rationale to future readers of the code. </details>

<h1 id="key-dimensions">Key Dimensions</h1>
<p><b>Summary:</b> Implement consistent dimensions to communicate information about views' keys to developers who use the view</p>
<details id="k1"> <!-- Primary keys required -->
	<summary><b>K1.</b> LookML views based on tables must define 1 or more Primary Key Dimensions.</summary>
	<p><b>Note:</b> "based on a table" could be either through a `sql_table_name`, `derived_table`, or implicit table name. Essentially, it's any view that's not a "field-only view" which will be joined using `join: {sql ;;}`</p>

	<code class="block good">
	view: carriers {
		sql_table_name: faa.carriers ;;
		dimension: 1pk_carrier_id {
			hidden: yes
			primary_key: yes
			sql:${TABLE}.id;;
		}
	}
  	</code>

	</details>
<details id="k2"> <!-- Primary key naming -->
	<summary><b>K2.</b> Primary Key Dimensions must be named like `<n>pk_<key_name>`...</summary>
	<p>..., where n is the total number of columns that form the primary key, and which may be omitted if it is 1, and key_name is any descriptive name.</p>
	<p><b>Rationale:</b> With this naming convention, anyone creating a join can conclusively find the correct logic without having to investigate:</p>

	<img src="img/pk-dimension-suggested.png" width="381" height="117" />

	<p>Additionally, anyone reading the join could conclusively verify it. </p>

	<h5>Example</h5>

	<code class="block good">
	view: membership {
	   sql_table_name: membership ;;
	   dimension: 2pk_user_id {hidden:yes sql:${TABLE}.user_id;;}
	   dimension: 2pk_group_id {hidden:yes sql:${TABLE}.group_id;;}
	   dimension: user_x_group {
	      hidden:yes
	      primary_key: yes
	      sql: ${2pk_user_id} || 'x' || ${2pk_group_id} ;;
	   }
	}

	explore: invitations {
	  join: membership {
	    relationship: many_to_one
	    sql_on: ${membership.2pk_user_id} = ${invitations.to_user_id}
	      AND   ${membership.2pk_group_id} = ${invitations.group_id} ;;
	    # ^ I can tell there MUST be only one membership. Looks good.
	  }
	}
	explore: users {
	  join: membership {
	    relationship: many_to_one
	    sql_on: ${membership.2pk_user_id} = ${users.id} ;;
	    # Uh-oh, something is wrong here!
	  }
	}
	</code>

	<h5>Notes</h5>

	<ul>
	<li> The number can (and must) be 0 in the rare case that you are working with a table with no primary key.
	<li> For keys with more than one column, all the numbers should be equal to the total number of columns. So, `3pk_a`, `3pk_b`, and `3pk_c`, NOT `1pk_a`, `2pk_b`, and `3pk_c`
	<li> For keys with more than one columns, this does mean you would need to define it in two ways. Once this way, and once as a single concatenated dimension with `primary_key: yes` (if necessary) so Looker can use it for generating symmetric aggregates. This is a small price to pay for the many instances of time saved looking up primary key information when writing/reading explores.
	</ul>

	</details>
<details id="k3"> <!-- Primary key location -->
	<summary><b>K3.</b> Primary Key Dimensions must be defined immediately following the table definition...</summary>
	<p>... and the table definition _should_ be defined before any other dimensions.</p>
	<p><b>Rationale:</b> By placing primary keys immediately below a derived table definition, users viewing the view file can easily verify that the primary key dimensions match the derived table's grouping (per rule T...).</p>
	</details>
<details id="k4"> <!-- Primary key hidden -->
	<summary><b>K4.</b> Primary Keys Dimensions should be hidden?	</summary>
	<p><b>Rationale:</b> The audience for PK information is developers. They use it to inform how to join and consume tables, and they can do so equally well with a hidden field.</p>
	<p><b>Note:</b> If a column that is a primary key should be user facing, you may want to expose it via a separate dimension.</p>
	</details>
<details id="k5"> <!-- Distribution dimensions -->
	<summary><b>K5.</b> LookML views based on tables with a distribution key should define a Distribution Key Dimension...</summary>
	<p>...named like <code>dpk_{key_name}</code></p>
	<p><b>Rationale:</b> By naming it similarly to Primary Keys, it will be suggested to anyone joining on a view as a possible join key. At the same time, the use of a `d` instead of a number allows it to be differentiated from a primary key</p>
	<p><b>Note:</b> If your database supports multiple projections of data, you may want to come up with a more sophisticated naming scheme instead.</p>
	</details>
<details id="k6"> <!-- Sort dimensions -->
	<summary><b>K6.</b> LookML views based on tables with a sort key should define one or more Sort Key dimensions</summary>
	<p><b>Note:</b> The name for this concept varies greatly from database to database, and you may want your naming scheme to reflect the native name for this concept in your particular database. "sk" is also not ideal in that it could be read as "surrogate key".</p>
	<p><b>Note:</b> If you have compound sort keys, it would be a good idea to include the rank of each column in the dimension name. Unlike the PK naming convention, each column should get a different numner, e.g. <code>idx1_site, idx2_date, idx3_country</code>.</p>
	</details>

<h1 id="other-fields">Other Fields</h1>
<p><b>Summary:</b> Implement fields in ways which (a) maximize the ability of developers to reuse them in the future, and (b) maximize the usability of explores for end users</p>
<details id="f1"> <!-- No inter-view dependencies -->
	<summary><b>F1.</b> Fields in a view should not reference other views...</summary>
	<p>... unless this is (A) a field-only view, or (B) a tightly coupled view (provide a base explore too!)</p>
	<p><b>Rationale:</b> Inter-view dependencies interfere with the re-use of the view<p>
	<code class="block bad">
	view: users {...}
	view: orders {
	  ...
	  measure: orders_per_user {
	    sql: ${count} / NULLIF(${users.count},0)
	  }
	}
	explore: orders {} # Errors :(
	</code>

	<code class="block good">
	view: users {...}
	view: orders {...}
	view: users_orders {
	  # No need for a sql_table_name or derived_table
	  measure: orders_per_user {
	    sql: ${orders.count} / NULLIF(${users.count},0)
	  }
	}
	explore: orders {} #Doesn't break like before!
	explore: users {
	  join: orders {...}
	  join: users_orders {
	    sql: ;;
	    # Use `sql` instead of `sql_on` and put some whitespace in it
	    relationship: one_to_one
	    view_label: "Orders" #For cleaner explore UI
	  }
	}
	</code>
	</details>
<details id="f2"><!-- No view-labeled fields -->
	<summary><b>F2.</b> Fields should not contain a view_label.</summary>
	<p><b>Rationale:</b> Field-level view labels can't be overridden by a join. Prefer view-level view labels.</p>
	</details>
<details id="f3"><!-- Count fields filtered -->
	<summary><b>F3.</b> All type:count measures must specify a filter</summary>
	<p>"Plain" count fields can/should specify a filter of "primary key dimensions are not null"</p>
	<p><b>Rationale:</b> By default Looker will implement any non-filtered & non-distinct count field as a `COUNT(*)`. Filtering such "plain" count on PK IS NOT NULL ensures correct counts in all of the following uses of the field: Counting just that table, counting that table when joined on as a one-to-one-or-zero table, counting that table with symmetric aggregates when joined on as a many_to_one table, and counting that table in explores with join paths.</b>
	<code class="block good">
	measure: count {
		type: count
		filters:{
			field: 1pk_user_id
			filter: "-null"
		}
	}
	</code>
	</details>
<details> <!-- Description or hidden -->
	<summary> Non-hidden fields should have descriptions</summary>
	<p><b>Rationale:</b> For a better user experience.</p>
	<p><b>Note:</b> Think about the audience when you write a description. Information for end users can go in the description, whereas information for other developers can go in a LookML comment</p>
	</details>
<details> <!-- ID fields hidden -->
	<summary> ID fields that do not have a business usage should be hidden</summary>
	<code class="good block">
	view: order_tems { ... 1pk_order_item_id {hidden:yes}}
	</code>
	</details>
<details> <!-- FK ID fields hidden -->
	<summary> ID fields that DO have a business usage should still be hidden when they are a foreign key</summary>
	<p><b>Rationale:</b> The ID field will make most sense for end users when they are exposed under the view for which they are a primary key.</p>
	<code class="bad block">
	view: order_items { ... dimension: order_id { ... description: "..." } }
	view: orders { ... dimension: id { ... hidden:yes }}
	</code>
	<code class="good block">
	view: order_tems { ... dimension: order_id { hidden:yes }}
	view: orders { ... dimension: id {... description: "..." }}
	</code>
	</details>
<details> <!-- Description or hidden -->
	<summary> Non-hidden fields should have a filter</summary>

	</details>


<h1 id="derived-tables">Derived Tables</h1>
<p><b>Summary:</b> Restrict the ways in which you write the SQL for derived tables in order to make them more modular and their results more realiable and understandable.</p>
<p><b>Note:</b> Even if you are using an external transformation tool like DBT, these practices are still applicable. Of course, using PDT's allows you to enforce these rules all in one place.</p>

<details id="t1"> <!-- Primary keys required -->
	<summary><b>T1.</b> Except for exceptions in T... & T..., every query, derived table, CTE, or subquery must SELECT a set of primary key columns following rules T2-T7</summary>
	<p><b>Rationale:</b> Primary keys define a contract that allows anyone reviewing the logic of a query to evaluate it modularly.
		Without them, any attempt to troubleshoot a query requires an arbitrarily deep investigation of related subqueries.
		With them, each query and subquery can be evaluated independently against their declared PK and the declared PK's of the participating tables.</p>

		<code class="good block">
		view: user_lifetime {derived_table: {sql:
			SELECT
				user_id as 1pk_user_id
				---
				COUNT(*) as lifetime_orders,
				SUM(amount) as lifetime_spend
			FROM orders
			GROUP BY user_id ;;}
		</code>

		<code class="bad block">
		view: user_lifetime {derived_table: {sql:
			SELECT
				user_id,
				COUNT(*) as lifetime_orders,
				SUM(amount) as lifetime_spend
			FROM orders
			GROUP BY 1 ;;}
		</code>

		<code class="bad block">
		derived_table: {sql:
			WITH orders AS (
				SELECT order_id, SUM(amount) FROM order_items
				GROUP BY 1
			)
			-- ^ The rule applies to CTE's/subqueries as well
			SELECT
				user_id as 1pk_user_id
				---
				COUNT(*) as lifetime_orders,
				SUM(amount) as lifetime_spend
			FROM orders
			GROUP BY user_id ;;}
		</code>
	</details>
<details id="t2"> <!-- Primary key naming -->
	<summary><b>T2.</b> Primary key columns must be aliased AS {n}pk_{column_name}...</summary>
	<p>...where {n} is the total number of columns in the primary key</p>
	<code class="good block">
	view: events_rollup {derived_table: {sql:
		SELECT
			site as 2pk_site,
			date as 2pk_date,
			---
			COUNT(*) as events
		FROM events
		GROUP BY site,date ;;}
	</code>
	<p><b>Note:</b> If you are using _in_query to generate a dynamic derived table where a column may or may not be present in the derived table's primary key, you should always select a static number of PK columns and conditionally NULL out their values, rather than selecting a dynamic number of columns.</p>

	<code class="bad block">
	view: dynamic_events_rollup {derived_table: {sql:
		SELECT
			site as 2pk_site,
			{% if date.date._in_query %} date as 2pk_date, {% endif %}
			---
			COUNT(*) as events
		FROM events
		GROUP BY site,date ;;}
	</code>
	<code class="good block">
	view: dynamic_events_rollup {derived_table: {sql:
		SELECT
			site as 2pk_site,
			{% if date.date._in_query %} date
			{% else %} NULL
			{% endif %} as 2pk_date,
			---
			COUNT(*) as events
		FROM events
		GROUP BY site,date ;;}
	</code>
	</details>
<details id="t3"> <!-- Primary key positioning -->
	<summary><b>T3.</b> Primary key columns must be the first columns in the SELECT clause</summary>
	<code class="bad block">
	derived_table: {sql:
		SELECT
			COUNT (*) as order_count,
			user_id as 1pk_user_id
		FROM orders
		GROUP BY user_id ;;}
	</code>
	</details>
<details id="t4"> <!-- Grouped PK starts... -->
	<summary><b>T4.</b> For grouped queries, the PK must start with one, more, or all of the grouped columns</summary>

	<h5>Notes</h5>
	<ul>
	<li>In most cases, unless you <i>intend</i> to use a window function to create sequence numbers within a partition, the primary key should simply be ALL of the grouped by fields.</li>
	<li>If you want to join a derived table on only a subset of its columns, what you probably want is to groups by ONLY those columns and then aggregate the rest (see example below)</li>
	</ul>

	<h5>Examples</h5>

	<code class="block bad">
	view: instance_daily {derived_table: {sql:
	SELECT
		events.instance_id as 2pk_instance_id,
		events.event_date as 2pk_event_date,
		---
		events.app_version,
		COUNT(*) as events
	FROM events
	GROUP BY 1,2,3
	;;}}
	</code>

	<code class="block questionable">
	view: instance_daily {derived_table: {sql:
	SELECT
		events.instance_id as 3pk_instance_id,
		events.event_date as 3pk_event_date,
		events.app_version as 3pk_app_version,
		---
		COUNT(*) as events
	FROM events
	GROUP BY 1,2,3
	;;}}
	</code>

	<code class="block questionable">
	view: instance_daily {derived_table: {sql:
	SELECT
		events.instance_id as 3pk_instance_id,
		events.event_date as 3pk_event_date,
		ROW_NUMBER() OVER (
			PARTITION BY events.instance_id, events.event_date
		) as 3pk_app_version_sequence
		---
		events.app_version,
		COUNT(*) as events
	FROM events
	GROUP BY 1,2
	;;}}
	</code>

	<p>Although the above two "questionable" examples satisfy rules T4 & T6, you will likely find that it is not natural to join them on their entire primary key when you try to use them elsewhere. </p>

	<code class="block good">
	view: instance_daily {derived_table: {sql:
	SELECT
		events.instance_id as 2pk_instance_id,
		events.event_date as 2pk_event_date,
		---
		MAX(events.app_version) as app_version,
		-- Maybe min too depending on business logic
		COUNT(*) as events
	FROM events
	GROUP BY 1,2
	</code>

	</details>
<details id="t5"> <!-- Ungrouped PK starts... -->
	<summary><b>T5.</b> For ungrouped queries, the PK must start with one, more, or all of the PK's from the many-joined tables</summary>


	</details>
<details id="t6"> <!-- PK continues with window -->
	<summary><b>T6.</b> If the SELECT did not use ALL of the available columns from T4 or T5, the PK must continue with a window function... </summary>

	</details>
<details id="t7"> <!-- PK may continue with aggregates -->
	<summary><b>T7.</b> The PK may continue with 0, 1, or more aggregates</summary>
	<p><b>Note:</b> Usually these are asserted unique aggregates as described in T11</p>
	</details>
<details id="t8"> <!-- PK ends with - - - -->
	<summary><b>T8.</b> Primary keys columns end with "---" on its own line</summary>

	</details>
<details id="t9"> <!-- SELECT 1 col allowed -->
	<summary><b>T9.</b> Subqueries and CTEs may SELECT a single column without declaring primary keys</summary>
	<p><b>Rationale:</b> Often, short subqueries are desired for existence or scalar logic that are (a) not reused outside of the current query, and (b) simple enough to read and understand that they can be analyzed in the context of the containing query with little added complexity</p>
	<p><b>Examples:</b></p>

	<code class="good block">
	view: new_orders {derived_table:{sql:
	SELECT
		1pk_order_id
	FROM orders
	WHERE order_date > (SELECT MAX(order_date) FROM order_rollup)
					 -- ^ This single-column subquery is exempt
	;;}}
	</code>

	<code class="good block">
	view: pending_users {derived_table:{sql:
	SELECT
		1pk_user_id
	FROM users
	WHERE id IN (SELECT user_id FROM orders WHERE status='Pending')
	           -- ^ This single-column subquery is exempt
	;;}}
	</code>

	</details>
<details id="t10"><!-- SELECT * from one table allowed -->
	<summary><b>T9.</b> Queries may SELECT &#42; (plus any non-pk columns) FROM a single table/subquery</summary>
	<p><b>Rationale:</b> Since this style of query/subquery simply passes on the PK attributes of the referenced table/query, it's reasonable to save time writing this query and for readers of your query to go find that PK information in that single other table/query.</p>
	<h5>Examples</h5>
	<code class="good block">
	view: customers {derived_table: {sql:
		SELECT *
		FROM ${accounts.SQL_TABLE_NAME}
		WHERE is_customer = TRUE
	;;}}
	</code>
	</details>
<details id="t11"><!-- Asserted uniques -->
	<summary><b>T...</b> Assert aggregates which should produce a single value</summary>
	<p><b>Rationale:</b> Rather than trusting/hoping the data will be what you want, we can ensure it and prevent bad data from propagating upstream</p>
	<code class="block good">
		MIN(col) as col,
		1 / CASE WHEN MIN(col) = MAX(col)
		THEN 1 ELSE 0 END as assert_col
	</code>
	</details>

<details><!-- min naming-->
	<summary><b>T...</b> MIN aggregates should be named ...</summary>

	</details>


<details><!-- max naming-->
	<summary><b>T...</b>MAX aggregates should be named ...</b>

	</details>

<details><!-- No order by-->
	<summary><b>T...</b>Queries should not have an ORDER BY clause</summary>
		<p>...unless a limit is also used</p>
	</details>

<h1 id="explores">Explores</h1>

<details id="e1"> <!-- Primary keys used -->
	<summary><b>E1</b> The "one" table in any join must be joined on equality constraints on all of the Primary Key Dimensions</summary>
	<p> This is relevant for any 1:1, 1:m, m:1, 1:0or1 joins. In otherwords, any non-many-to-many join (which you should only be using with great caution)</p>
	<h5>Examples</h5>
	<code class="good block">
	join: users {
	  relationship: many_to_one
	  sql_on: ${1pk_user_id} = ${orders.user_id} ;;
	}
	</code>

	<code class="bad block">
	join: users {
	  relationship: many_to_one
	  sql_on: ${users.id} = ${orders.user_id} ;;
	  # ^ I can only _hope_ that this is right, or spend time verifying it
	}
	</code>

	<code class="questionable block">
	join: dates {
	  relationship: many_to_many
	  sql_on: ${dates.1pk_date} >= $[users.created_date} AND ${dates.1pk_date} <= $[users.deleted_date} ;;
	}
	</code>

	</details>
<details id="e2"> <!-- Join on dist key and sort keys when possible -->
	<summary><b>E2.</b> Joins should use distribution keys and sort keys when possible</summary>
	<h5>Examples</h5>
	<code class="good block">
	explore: order_items {
		join: orders {
			relationship: many_to_one
			sql_on: ${orders.1pk_id} = ${order_items.order_id}
				AND ${orders.dpk_user_id} = ${order_items.dpk_user_id}
			;; # Results in a hash join with no network activity
		}
	}
	</code>
	<code class="good block">
	explore: entities {
		join: eav_attribute1 {
			relationship: one_to_one
			sql_on: ${eav_attribute1.2pk_entity_id} = ${entities.id}
				AND ${eav_attribute1.2pk_attribute_id} = 1
				AND ${eav_attribute1.dpk_entity_id} = ${order_items.dpk_entity_id}
				AND ${eav_attribute1.idx_entity_id} = ${order_items.idx_entity_id}
			;; # Results in a merge join with no network activity
		}
		join: eav_attribute2 {
			relationship: one_to_one
			sql_on: ${eav_attribute2.2pk_entity_id} = ${entities.id}
				AND ${eav_attribute2.2pk_attribute_id} = 2
				AND ${eav_attribute2.dpk_entity_id} = ${order_items.dpk_entity_id}
				AND ${eav_attribute2.idx_entity_id} = ${order_items.idx_entity_id}
			;; # Results in a merge join with no network activity
		}
	}
	</code>
	<p><b>Note:</b> In the EAV example, even though the first part of the primary key, the distribution key, and the sort key all result in `entity_id`, writing them out multiple times with the different key dimensions communicates what they do to anyone reading the join, and should have negligible performance impact.</p>
	</details>
<details id="e3"> <!-- always_filter on sortkey -->
	<summary><b>E3.</b> Explores should declare `always_filter` on the base table's sort key / parition column / clustered index</summary>
	<code class="good block">
	explore: events {
		always_filter: {
		...TODO
		}
	}
	</code>
	</details>
<details id="e4"> <!-- avoid multiplicative fanout -->
	<summary><b>E4.</b> Avoid multiplicative fanout</summary>
	<p>...TODO</p>
	</details>

<h1 id="out-of-scope">Out of Scope</h1>
<p>The following subjects are not in the scope of this ruleset, but are still valuable to know about! These contain links to the most useful resources I could find on these subjects<p>
<details>
	<summary>Change management</summary>
	<p>This is something I really wanted to include, but was not able to this time around. Something like semver. Hopefully a future version will include this. (Pull requests will be considered!)</p>
	</details>
<details>
	<summary>Defining distribution, sort keys, indexes, etc</summary>
	<p>These are super important, but the strategy for these is too broad and complex to fit into this kind of ruleset.</p>
	<!--However, you can check out some of these useful resources: <ol>
		<li></li>
	</ol> -->
	</details>
<details>
	<summary>Whitespace, capitalization</summary>
	<p>I don't personally care for rules constraining indentation, capitalization, and the like, but if you do, here's a possible <a href="https://gist.github.com/fredbenenson/7bb92718e19138c20591">SQL style guide</a></p>
	</details>
<details>
	<summary>EAV Schemas</summary>
	<p>Entity-Attribute-Value schemas come with their own modeling challenges, but are not relevant to many models, so I decided to leave them out of this ruleset.</p>
	<!-- However, you can get some guidance by studying these two articles:<p> -->
	</details>
</body></html>
